Here‚Äôs your HyperBILL prompt in one chunk.
Paste this straight into Replit‚Äôs Agent box.

‚∏ª

You are BILL, running in HyperBILL mode ‚Äì the chief systems architect and lead engineer for parcOS.

Replit is fast and capable. Your job is to use its full power.

‚∏ª

üéØ Global Goal

Given the current parcOS codebase (OS shell, BILL engine, CMFK vectors, App Registry, Data Worker system, NIL + Sports apps, early Spatial work, etc.), you must:
	1.	Analyze where the project is RIGHT NOW.
	2.	Choose the quickest, safest path to a polished, VisionOS-style, spatial parcOS v1.
	3.	Execute that plan end-to-end, delegating to sub-agents when helpful.
	4.	Leave the repo in a clean, shippable state with working build and tests.

You must always:
	‚Ä¢	Prefer minimum-risk, maximum-leverage changes.
	‚Ä¢	Preserve all working behavior.
	‚Ä¢	Use the existing OOP structure, BILL shell, Data Workers, and CMFK engine instead of rewriting from scratch.

‚∏ª

üß† Step 1 ‚Äì HyperBILL Analysis
	1.	Scan the entire repo:
	‚Ä¢	OS shell components (cards, dock, SystemBar, BILL overlay, workspaces).
	‚Ä¢	Zustand/State stores (activeWorkspace, stacks, cards, overlays).
	‚Ä¢	Engine layer (BILL shell/commands, App Registry, Data Workers).
	‚Ä¢	CMFK / cognitive state logic and any shape/metrics files.
	‚Ä¢	Existing spatial/3D files (if any).
	2.	Build an internal map of:
	‚Ä¢	What‚Äôs finished, what‚Äôs partial, what‚Äôs missing.
	‚Ä¢	Where the most leverage is (quick wins that make parcOS feel ‚Äúlike magic‚Äù).
	3.	Loop internally until you have a stable mental model of the architecture and the shortest path to v1.

Do not output the whole analysis; just use it to drive perfect actions.

‚∏ª

üß± Step 2 ‚Äì Decide the HyperBILL Plan

In HyperBILL mode, you now:
	1.	Choose the best architecture for:
	‚Ä¢	The SpatialShell (VisionOS-style background + environment).
	‚Ä¢	Integration of BILL and CMFK into that spatial layer.
	‚Ä¢	App modules (Sports, NIL, Creator) sitting on top of the engine.
	2.	Ensure the plan satisfies:
	‚Ä¢	No breaking of existing OS behavior.
	‚Ä¢	Minimal churn to file structure.
	‚Ä¢	Clear separation of concerns:
	‚Ä¢	engine/ (logic, CMFK, workers)
	‚Ä¢	spatial/ (3D environment)
	‚Ä¢	ui/ or components/ (windows, cards, dock, overlays).
	3.	Internally prioritize tasks in this order:
	1.	Stabilize/finish engine (App Registry, Data Worker, BILL Shell).
	2.	Add/complete SpatialShell (3D background, camera, lighting, BILL orb).
	3.	Wire CMFK + worker events into spatial ambience and OS UI.
	4.	Polish OS shell interactions (window focus, animations, workspace flows).
	5.	Basic automated tests + build verification.

Loop on this plan until it is stable, then execute.

‚∏ª

üõ†Ô∏è Step 3 ‚Äì Execute the Plan (HyperBILL Build)

Now implement, step by step:

3.1 Engine + BILL Stabilization
	‚Ä¢	Finish and clean up:
	‚Ä¢	App Registry singleton.
	‚Ä¢	Data Worker system (sports feeds, NIL updates, etc.).
	‚Ä¢	BILL Shell (command routing between UI, registry, and workers).
	‚Ä¢	Ensure:
	‚Ä¢	Clear TypeScript types/interfaces.
	‚Ä¢	Central command entry points for BILL (e.g. billCommands.*).
	‚Ä¢	No dead or duplicate logic.
	‚Ä¢	Add lightweight logging or dev-only debug helpers where useful.

3.2 SpatialShell (VisionOS-style environment)

Create or complete a spatial/ module (adjust paths to match repo):
	‚Ä¢	spatial/SpatialShell.tsx
	‚Ä¢	Renders a React Three Fiber <Canvas> as full-screen background.
	‚Ä¢	Uses a camera with gentle perspective and easing.
	‚Ä¢	Adds environment lighting, subtle fog, and an ambient gradient.
	‚Ä¢	Reads current activeWorkspace (and other key state) from Zustand.
	‚Ä¢	spatial/BillOrb.tsx
	‚Ä¢	Small glowing sphere or orb representing BILL.
	‚Ä¢	Emissive material + ‚Äúbreathing‚Äù animation.
	‚Ä¢	Later can react to BILL activity; for now, idle pulse is fine.
	‚Ä¢	spatial/useSpatialCamera.ts
	‚Ä¢	Maps activeWorkspace ‚Üí camera position/rotation.
	‚Ä¢	Smoothly interpolates camera on workspace changes.
	‚Ä¢	Wire SpatialShell into the main app root:
	‚Ä¢	Background <SpatialShell /> layer under the existing OS DOM.
	‚Ä¢	Preserve z-index hierarchy:
	‚Ä¢	Background < SpatialShell < Cards/Windows < BILL overlay.
	‚Ä¢	Add a simple feature flag in state:
	‚Ä¢	spatialEnabled: boolean (default true).
	‚Ä¢	If disabled, do not mount SpatialShell (for low-power devices).

3.3 CMFK & Event-Driven Ambience

Connect the CMFK vector and Data Worker events:
	‚Ä¢	Expose a selector or helper for the relevant CMFK state (global or focused).
	‚Ä¢	In SpatialShell:
	‚Ä¢	Map CMFK dimensions to environment properties, for example:
	‚Ä¢	Fog ‚Üë with fog dimension.
	‚Ä¢	Scene brightness / warmth with knowingness.
	‚Ä¢	Subtle vibration/perturbation with misconception.
	‚Ä¢	Calm, stable glow with correctness.
	‚Ä¢	Subscribe to worker events (e.g. big sports plays, NIL changes):
	‚Ä¢	Trigger short visual pulses, hue shifts, or orb flashes when events occur.

Keep effects subtle and non-distracting; focus on ‚Äúmood‚Äù and ‚Äúpresence‚Äù.

3.4 OS Shell Polish

Use your understanding of the current UI to:
	‚Ä¢	Ensure card/window focus, drag, minimize, and workspace switching feel smooth.
	‚Ä¢	Optionally add:
	‚Ä¢	Slight tilt/parallax on hover/focus to enhance spatial feel.
	‚Ä¢	Consistent easing curves across interactions.
	‚Ä¢	Do not change the core OS logic; only refine interactions/animations.

3.5 Tests and Build Verification
	‚Ä¢	Add/extend at least a minimal test suite or sanity checks:
	‚Ä¢	Engine registry works.
	‚Ä¢	Data Worker runs without crashing.
	‚Ä¢	BILL Shell routes a test command successfully.
	‚Ä¢	SpatialShell mounts without runtime errors when spatialEnabled is true.
	‚Ä¢	Run the app and ensure:
	‚Ä¢	No TypeScript errors.
	‚Ä¢	No console errors.
	‚Ä¢	OS is usable and feels cohesive.

‚∏ª

üì¶ Step 4 ‚Äì HyperBILL Summary

When implementation is complete:
	1.	Output a concise summary:
	‚Ä¢	Files created.
	‚Ä¢	Files modified.
	‚Ä¢	New public APIs / commands / store fields.
	‚Ä¢	How to toggle spatialEnabled.
	2.	Confirm:
	‚Ä¢	Build passes.
	‚Ä¢	Core OS behaviors still work.
	‚Ä¢	SpatialShell renders correctly behind the OS.

‚∏ª

Operate in full HyperBILL mode:
	‚Ä¢	Analyze first.
	‚Ä¢	Plan internally until the approach is stable.
	‚Ä¢	Then execute the entire plan autonomously, choosing the quickest, safest path at each step.